---
layout: default
title: AOC 2016 - Day 1, Part 2
date: '2017-02-26T13:22:00.000-06:00'
author: Sachin
tags:
- F#
- AdventOfCode
modified_time: '2017-02-26T20:47:32.110-06:00'
blogger_id: tag:blogger.com,1999:blog-36337335936526669.post-8252354285166794385
blogger_orig_url: https://www.znprojects.com/2017/02/aoc-2016-day-1-part-2.html
---

  <style type="text/css">code{white-space: pre;}</style>  <style type="text/css">div.sourceCode { overflow-x: auto; } table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {   margin: 0; padding: 0; vertical-align: baseline; border: none; } table.sourceCode { width: 100%; line-height: 100%; } td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; } td.sourceCode { padding-left: 5px; } code > span.kw { color: #007020; font-weight: bold; } /* Keyword */ code > span.dt { color: #902000; } /* DataType */ code > span.dv { color: #40a070; } /* DecVal */ code > span.bn { color: #40a070; } /* BaseN */ code > span.fl { color: #40a070; } /* Float */ code > span.ch { color: #4070a0; } /* Char */ code > span.st { color: #4070a0; } /* String */ code > span.co { color: #60a0b0; font-style: italic; } /* Comment */ code > span.ot { color: #007020; } /* Other */ code > span.al { color: #ff0000; font-weight: bold; } /* Alert */ code > span.fu { color: #06287e; } /* Function */ code > span.er { color: #ff0000; font-weight: bold; } /* Error */ code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */ code > span.cn { color: #880000; } /* Constant */ code > span.sc { color: #4070a0; } /* SpecialChar */ code > span.vs { color: #4070a0; } /* VerbatimString */ code > span.ss { color: #bb6688; } /* SpecialString */ code > span.im { } /* Import */ code > span.va { color: #19177c; } /* Variable */ code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */ code > span.op { color: #666666; } /* Operator */ code > span.bu { } /* BuiltIn */ code > span.ex { } /* Extension */ code > span.pp { color: #bc7a00; } /* Preprocessor */ code > span.at { color: #7d9029; } /* Attribute */ code > span.do { color: #ba2121; font-style: italic; } /* Documentation */ code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */ code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */ code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */   </style>  <!--[if lt IE 9]>    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>  <![endif]--><h1 id="aoc-2016---day-1-part-2"><a href="http://adventofcode.com/2016/day/1">AOC 2016 - Day 1, Part 2</a></h1><p><em>If you just want to jump into the code, the code for Day 1 is on <a href="https://github.com/zakaluka/fsaoc2016/blob/master/1/OneMain.fsx">GitHub</a>.</em></p><h2 id="the-problem">The problem</h2><p>Part 2 adds a small twist to the problem. Instead of just finding an end-point, you have to find the first block that you visit twice.</p><p>This is not as simple as checking against the end points of each move. Rather each intermediate block that you visit is a candidate for being the final answer.</p><h3 id="note-about-the-problem">Note about the problem</h3><p>If you have not finished Day 1, Part 1 yet, the AOC website will not show you the Part 2 text. If you need to do Day 1, Part 1, please see my <a href="https://znprojects.blogspot.com/2017/02/aoc-2016-day-1-part-1.html">post on that subject</a>.</p><h2 id="do-the-lines-intersect">Do the lines intersect?</h2><p>There are a few ways to solve this problem.</p><ol type="1"><li>Keep a list of all <code>Point</code>s (as sets of 2D Cartesian coordinates). Then, every time you move, check if you are passing over an already visited block.</li><li>Store the lines that represent the moves you have made so far, in order. Then, when making a new move, check whether the new 'line of movement' intersects with any of the previous lines. If there is an intersection, find the point of intersection.</li></ol><p>I first thought of implementing solution #1, but found solution #2 more interesting because I do not currently know how to calculate whether two lines intersect or what that intersection point is.</p><p>So, I started out by reading about lines and intersections. I started with various &quot;game&quot; / graphical algorithms because I assumed that this is a problem that game developers encounter often. Like most people (I imagine), I first ended up at <a href="https://en.wikipedia.org/wiki/Lineâ€“line_intersection">Wikipedia</a>. This is a great article that is heavy on theory and light on implementation details. A lot of the information, not only on Wikipedia but on various sites, involves knowing the equation of the line. I had the end-points, but did not readily have the slope-intercept form of the lines. After quite a bit of searching, I ended up on Martin Thoma's article, <a href="https://martin-thoma.com/how-to-check-if-two-line-segments-intersect/">How to check if two line segments intersect</a>.</p><p>I highly recommend reading this article if you haven't seen it before. He has an excellent explanation of line-line intersection. I actually implemented most of Martin's code (in F#) and it is quite solid. But then, I started reading Gregory Stein's comment on the same page regarding cross products of vectors. I really liked Gregory's idea, mainly due to the succinctness of the code. So, I also translated Gregory's code to F#. In the end, I went with Gregory's algorithm.</p><p>Here is what Gregory's code came out as:</p><div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><span class="kw">let</span> doLinesIntersect2 l1 l2 =<br />  <span class="kw">let</span> A = fst l1<br />  <span class="kw">let</span> B = snd l1<br />  <span class="kw">let</span> O = fst l2<br />  <span class="kw">let</span> M = snd l2<br />  <span class="kw">let</span> v1 = {x = A<span class="kw">.</span>x - O<span class="kw">.</span>x; y = A<span class="kw">.</span>y - O<span class="kw">.</span>y}<br />  <span class="kw">let</span> v2 = {x = B<span class="kw">.</span>x - O<span class="kw">.</span>x; y = B<span class="kw">.</span>y - O<span class="kw">.</span>y}<br />  <span class="kw">let</span> v3 = {x = M<span class="kw">.</span>x - O<span class="kw">.</span>x; y = M<span class="kw">.</span>y - O<span class="kw">.</span>y}<br />  <span class="kw">let</span> v4 = {x = A<span class="kw">.</span>x - M<span class="kw">.</span>x; y = A<span class="kw">.</span>y - M<span class="kw">.</span>y}<br />  <span class="kw">let</span> v5 = {x = B<span class="kw">.</span>x - M<span class="kw">.</span>x; y = B<span class="kw">.</span>y - M<span class="kw">.</span>y}<br /><br />  <span class="kw">let</span> v4 = {x = v4.x + v5.x; y = v4.y + v5.y}<br />  <span class="kw">let</span> v5 = {x = v1.x + v2.x; y = v1.y + v2.y}<br />  <span class="kw">let</span> dotProduct = v4.x * v5.x + v4.y * v5.y<br /><br />  <span class="kw">if</span> dotProduct &gt; <span class="dv">0</span> <span class="kw">then</span> <span class="kw">false</span><br />  <span class="kw">else</span> (<br />    <span class="kw">let</span> crossV1V3 = v1.x*v3.y - v1.y*v3.x<br />    <span class="kw">let</span> crossV3V2 = v3.x*v2.y - v3.y*v2.x<br />    (crossV1V3 &lt; <span class="dv">0</span>) = (crossV3V2 &lt; <span class="dv">0</span>)<br />  )</code></pre></div><p>I can safely confirm that this code <strong>does</strong> work. This function has signature <code>Point * Point -&gt; Point * Point -&gt; bool</code>. Recall from Day 1 that a <code>Point</code> and a <code>Location</code> are defined as:</p><div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><span class="kw">type</span> Point = {<br />  x : <span class="dt">int</span><br />  y : <span class="dt">int</span><br />}<br /><br /><span class="kw">type</span> Location = {<br />  dir : Direction<br />  pt : Point<br />}</code></pre></div><p>Initially, my x-y coordinates were saved directly in the <code>Location</code> record. However, once I decided on a solution for Part 2, I actually went back, changed the data types, and refactored the Part 1 code so that it would continue working.</p><h2 id="where-do-they-intersect">Where do they intersect?</h2><p>Once I knew that two lines intersect, the next job was to find the intersection point. I looked at a number of sites and ended up adapting the code from <a href="http://www.ahristov.com/tutorial/geometry-games/intersection-lines.html">Intersection of lines in 2D</a>.</p><div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><span class="kw">let</span> intersectionPoint l1 l2 =<br />  <span class="kw">let</span> x1 = (fst l1).x<br />  <span class="kw">let</span> y1 = (fst l1).y<br />  <span class="kw">let</span> x2 = (snd l1).x<br />  <span class="kw">let</span> y2 = (snd l1).y<br />  <span class="kw">let</span> x3 = (fst l2).x<br />  <span class="kw">let</span> y3 = (fst l2).y<br />  <span class="kw">let</span> x4 = (snd l2).x<br />  <span class="kw">let</span> y4 = (snd l2).y<br /><br />  <span class="kw">let</span> denom = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4)<br />  {x = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/denom;<br />  y = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/denom}</code></pre></div><p>This function's signature is <code>Point * Point -&gt; Point * Point -&gt; Point</code>. It takes 2 lines, each represented as a pair of <code>Point</code>s, and returns the intersection <code>Point</code>.</p><h2 id="putting-it-all-together">Putting it all together</h2><p>I wanted to re-use, as much as possible, the code I had already written for <a href="https://znprojects.blogspot.com/2017/02/aoc-2016-day-1-part-1.html">Day 1, Part 1</a>. Specifically, I wanted to re-use the <code>move</code> mechanic. To achieve this goal, I wrote my final function per the following spec:</p><ol type="1"><li>Parse the instructions</li><li>Perform the moves while preserving all intermediate <code>Location</code>s.</li><li>Extract the <code>Point</code>s from the <code>Location</code>s, since the <code>Direction</code> isn't important once the moves are complete.</li><li>Create conceptual lines by creating pairs of individual <code>Point</code>s.</li><li>Iterate over the list of Lines (which are really just <code>Point</code> tuples) to find an intersection, but with a built-in short-circuit. Once we find an intersection point, we don't want to update it again in the future.</li><li>Finally, pull out the intersection point (if any) and calculate the distance from the <code>startPt</code> (which is at <code>(0,0)</code>).</li></ol><p>The things I love about F# is that I was able to translate this spec almost line-for-line into code. I called this function <code>dupFinder</code> because I figured that we are trying to find the first <code>Point</code> that is a duplicate in the route we have traveled thus far:</p><div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><span class="kw">let</span> dupFinder strList =<br />  Regex<span class="kw">.</span>Matches (strList, @<span class="st">&quot;[LR]\d+&quot;</span>)<br />  |&gt; Seq<span class="kw">.</span>cast<br />  |&gt; Seq<span class="kw">.</span>scan<br />    (<span class="kw">fun</span> oldloc (instr : System<span class="kw">.</span>Text<span class="kw">.</span>RegularExpressions<span class="kw">.</span>Match) -&gt;<br />      move<br />        (instr.Value<span class="kw">.</span>[<span class="dv">0</span>] |&gt; toTurn)<br />        (instr.Value<span class="kw">.</span>Substring <span class="dv">1</span> |&gt; <span class="dt">int</span>)<br />        oldloc<br />    )<br />    startLoc<br />  |&gt; Seq<span class="kw">.</span>map (<span class="kw">fun</span> x -&gt; x.pt)<br />  //<span class="co"> Define lines</span><br />  |&gt; Seq<span class="kw">.</span>pairwise<br />  |&gt; Seq<span class="kw">.</span>fold<br />    (<span class="kw">fun</span> accum elt -&gt;<br />      <span class="kw">if</span> snd accum = None <span class="kw">then</span><br />        <span class="kw">let</span> s = fst accum<br />        <span class="kw">if</span> Seq<span class="kw">.</span>exists (doLinesIntersect2 elt) s <span class="kw">then</span><br />          <span class="kw">let</span> ip = Seq<span class="kw">.</span>find (doLinesIntersect2 elt) s<br />          s, intersectionPoint ip elt |&gt; Some<br />        <span class="kw">else</span> s @ [elt], None<br />      <span class="kw">else</span> accum<br />    )<br />    ([], None)<br />  |&gt; snd<br />  |&gt; <span class="kw">fun</span> x -&gt;<br />    <span class="kw">match</span> x <span class="kw">with</span><br />    | None -&gt; failwith <span class="st">&quot;No intersection&quot;</span><br />    | Some y -&gt; y<br />  |&gt; distance startPt</code></pre></div><p>And this is it. I invoked the <code>dupFinder</code> function with the input string (<a href="https://github.com/zakaluka/fsaoc2016/blob/master/1/OneMain.fsx#L207">same string as Part 1</a>) and got the correct answer.</p><p>The answer you get with this code is <code>141</code>, which is, in fact, correct.</p><p>If you want to see the code for Day 1 (both parts), please head over to <a href="https://github.com/zakaluka/fsaoc2016/blob/master/1/OneMain.fsx">GitHub</a>.</p><h2 id="but-what-about-testing">But what about testing?</h2><p>As you may have noticed, I barely have any testing in my code. In the beginning, I debugged by code using a combination of code reading (gotta love static typing!) and the <code>tee</code> function to print debugging information during execution.</p><p>If you are not aware of <code>tee</code>, I highly recommend reading <a href="https://davefancher.com/2015/01/11/extending-f-pipelines-with-a-tee-function/">Extending F# Pipelines With A Tee Function</a> and Scott Wlaschin's <a href="http://fsharpforfunandprofit.com/posts/recipe-part2/">Railway oriented programming</a>.</p><p>Here is the code for <code>tee</code>:</p><div class="sourceCode"><pre class="sourceCode fsharp"><code class="sourceCode fsharp"><span class="kw">let</span> tee f x =<br />  f x |&gt; ignore<br />  x</code></pre></div><p>This handy little function allows you to inject arbitrary commands (such as <code>printfn</code> or <code>logger.Log</code>) into the middle of a pipe chain without disturbing the rest of the code. It takes a function and an argument, executes the function, ignores the result (if any), and passes the original argument forward. Obviously, this wouldn't work so well if the function somehow mutated the argument. Luckily, F# makes it at least a little annoying to write functions that mutate values, and I almost always only use <code>tee</code> to do mid-pipe log entries / debug output.</p><p>See you next time!</p>
